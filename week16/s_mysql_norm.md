## ARTS

### Share

## MySql规范


# **一、基础规范**

* 表存储引擎必须使用InnoDB, 支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高

* 表字符集默认使用utf8，必要时候使用utf8mb4


          解读：

         （1）通用，无乱码风险，汉字3字节，英文1字节

         （2）utf8mb4是utf8的超集，有存储4字节例如表情符号时，使用它

* 禁止使用存储过程，视图，触发器，Event


         解读：

         （1）对数据库性能影响较大，互联网业务，能让站点层和服务层干的事情，不要交到数据库层

         （2）调试，排错，迁移都比较困难，扩展性较差

* 禁止在数据库中存储大文件，例如照片，可以将大文件存储在对象存储系统，数据库中存储路径

* 禁止在线上环境做数据库压力测试

* 测试，开发，线上数据库环境必须隔离

# **二、命名规范**

* 库名，表名，列名必须用小写，采用下划线分隔


          解读：abc，Abc，ABC都是给自己埋坑,

* 库名，表名，列名必须见名知义，长度不要超过32字符


         解读：tmp，wushan谁TM知道这些库是干嘛的

* 库备表必须以bak为前缀，以日期为后缀


         解读：bak_oms_orders_20180101

* 库备份必须以bak为前缀，以日期为后缀，例如：bak_pop_20180101

# **三、表设计规范**

* 必须添加对应业务前缀，例如oms,pms等，与后面名称_连接

* 单实例表个数必须控制在2000个以内

* 单表分表个数必须控制在1024个以内

* 表必须有主键，推荐使用UNSIGNED整数为主键


         潜在坑：删除无主键的表，如果是row模式的主从架构，从库会挂住

* 禁止使用外键，如果要保证完整性，应由应用程式实现


         解读：外键使得表之间相互耦合，影响update/delete等SQL性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈

* 建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据

# **四、列设计规范**

* 列必须添加合适的备注，如果是枚举需把相关值写上，例如订单表状态字段备注写:订单状态,placed(下单成功)，settled(扣款成功), assorting（备货中）

* 根据业务区分使用tinyint/int/bigint，分别会占用1/4/8字节

* 根据业务区分使用char/varchar


         解读：

      （1）字段长度固定，或者长度近似的业务场景，适合使用char，能够减少碎片，查询性能高

      （2）字段长度相差较大，或者更新较少的业务场景，适合使用varchar，能够减少空间

* 根据业务区分使用datetime/timestamp,


         解读：

        (1)DATETIME的日期范围是1001-9999年，TIMESTAMP的时间范围是1970-2038年。前者占用5个字节，后者占用4个字节，存储年使用YEAR，存储日期使用DATE，存储时间使用datetime

        (2)这两个字段争议较大，没有一定的定论，没有特殊情况全部使用datetime类型，像updated_at字段用timestamp。

* 必须把字段定义为NOT NULL并设默认值


         解读：

      （1）NULL的列使用索引，索引统计，值都更加复杂，MySQL更难优化

      （2）NULL需要更多的存储空间

      （3）NULL只能采用IS NULL或者IS NOT NULL，而在=/!=/in/not in时有大坑

* 使用INT UNSIGNED存储IPv4，不要用char(15)

* 不要使用TEXT、BLOB类型：会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能,如果必须要使用则独立出来一张表，用主键来对应，避免影响其它字段索引效率

* 使用varchar(20)存储手机号，不要使用整数


         解读：

      （1）牵扯到国家代号，可能出现+/-/()等字符，例如+86

      （2）手机号不会用来做数学运算

      （3）varchar可以模糊查询，例如like ‘138%’

使用TINYINT来代替ENUM


* 解读：ENUM增加新值要进行DDL操作



为提高效率可以牺牲范式设计，冗余数据。先简单熟悉数据库范式：

第一范式(1NF)：字段值具有原子性,不能再分(所有关系型数据库系统都满足第一范式); 例如：姓名字段,其中姓和名是一个整体,如果区分姓和名那么必须设立两个独立字段;

第二范式(2NF)：一个表必须有主键,即每行数据都能被唯一的区分; 备注：必须先满足第一范式;

* 第三范式(3NF)：一个表中不能包涵其他相关表中非关键字段的信息,即数据表不能有沉余字段; 备注：必须先满足第二范式; 备注：往往我们在设计表中不能遵守第三范式,因为合理的沉余字段将会给我们减少join的查询; 例如：相册表中会添加图片的点击数字段,在相册图片表中也会添加图片的点击数字段;，               


         解读：         

         (1)不可死扣范式不是频繁修改的字段

         (2)不是 varchar 超长字段，更不能是 text 字段

# **五、索引规范**

* 唯一索引使用uniq_[字段名]来命名

* 非唯一索引使用idx_[字段名]来命名

* 单张表索引数量建议控制在5个以内


         解读：

      （1）互联网高并发业务，太多索引会影响写性能

      （2）生成执行计划时，如果索引太多，会降低性能，并可能导致MySQL选择不到最优索引

      （3）异常复杂的查询需求，可以选择ES等更为适合的方式存储

* 组合索引字段数不建议超过5个


         解读：如果5个字段还不能极大缩小row范围，八成是设计有问题

* 不建议在频繁更新的字段上建立索引

* 非必要不要进行JOIN查询，如果要进行JOIN查询，被JOIN的字段必须类型相同，并建立索引


         解读：踩过因为JOIN字段类型不一致，而导致全表扫描的坑么？

* 理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c)

# **六、SQL规范**

* 禁止使用select *，只获取必要字段


         解读：

       （1）select *会增加cpu/io/内存/带宽的消耗

       （2）指定字段能有效利用索引覆盖

       （3）指定字段查询，在表结构变更时，能保证对应用程序无影响

* insert必须指定字段，禁止使用insert into T values()


         解读：指定字段插入，在表结构变更时，能保证对应用程序无影响

隐式类型转换会使索引失效，请使用“同类型”进行比较，否则导致全表扫描：


* SELECT name FROM t_user WHERE phone=1333333333 会导致全表扫描.

* 禁止在where条件列使用函数或者表达式


         解读：导致不能命中索引，全表扫描，SELECT naem FROM tuser WHERE date(createdatatime)='2017-12-15' 会导致全表扫描

        推荐的写法是：SELECT name FROM tuser WHERE createdatatime>= '2017-02-15 ' and create_datatime < '2017-02-16 

减少或禁止负向查询以及%开头的模糊查询


解读：

(1）负向查询条件：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE等，会导致全表扫描。这条争议较大，有童鞋会说不用部分业务实现不了，一般来说where后可能还会跟其他条件，尽量根据最左原则把正向条件前置，再用负向条件，直接把负向条件放在最左会导致全表扫描，索引失效，mysql cpu可能急剧上升。

* (2）%开头的模糊查询，会导致全表扫描，索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引, 如果需要请走搜索引擎来解决

* 禁止大表JOIN和子查询，会产生临时表，消耗较多内存与CPU，极大影响数据库性能

* 同一个字段上的OR必须改写问IN, OR不会走索引,IN的值必须少于50个

* 不要一次更新大量数据: 数据更新会对行或者表加锁，应该分为多次更新

* 应用程序必须捕获SQL异常


         解读：方便定位线上问题


